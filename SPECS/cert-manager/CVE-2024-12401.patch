From a96aba7d1292047567715ba3e2f70252892ea2b3 Mon Sep 17 00:00:00 2001
From: Ashley Davis <ashley.davis@venafi.com>
Date: Fri, 1 Nov 2024 14:46:10 +0000
Subject: security: Add functions to limit max PEM sizes allowable

Includes a lot of comments explaining how the maxima were calculated.
This is _very_ conservative, and assumes we're dealing with RSA keys
twice the size of what we actually allow as a maximum.

From running the included benchmark it seems the pathological runtime is
about 13617196ns (13ms) on an M2 Max which seems acceptable.

Signed-off-by: Ashley Davis <ashley.davis@venafi.com>
---
 internal/pem/decode.go                        | 124 ++++++++++++++
 internal/pem/decode_test.go                   | 160 ++++++++++++++++++
 .../testdata/issue-ghsa-r4pg-vg54-wxx4.bin    | Bin 0 -> 876105 bytes
 pkg/util/pki/generate_keysize_test.go         |  27 +++
 pkg/util/pki/parse.go                         |   2 +-
 5 files changed, 312 insertions(+), 1 deletion(-)
 create mode 100644 internal/pem/decode.go
 create mode 100644 internal/pem/decode_test.go
 create mode 100644 internal/pem/testdata/issue-ghsa-r4pg-vg54-wxx4.bin
 create mode 100644 pkg/util/pki/generate_keysize_test.go

diff --git a/internal/pem/decode.go b/internal/pem/decode.go
new file mode 100644
index 0000000..cf0b87e
--- /dev/null
+++ b/internal/pem/decode.go
@@ -0,0 +1,124 @@
+/*
+Copyright 2024 The cert-manager Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+// Package pem provides utility functions for safely decoding PEM data, placing upper limits on the size
+// of data that will be processed. It functions as an extension to the standard library "encoding/pem" functions.
+package pem
+
+import (
+	stdpem "encoding/pem"
+	"errors"
+	"fmt"
+)
+
+// The constants below are estimates at reasonable upper bounds for sizes of PEM data that cert-manager might encounter.
+// cert-manager supports RSA, ECDSA and Ed25519 keys, of which RSA keys are by far the largest.
+
+// We'll aim to support RSA certs / keys which are larger than the maximum size (defined in pkg/util/pki.MaxRSAKeySize).
+
+// RSA keys grow proportional to the size of the RSA key used. For example:
+// PEM-encoded RSA Keys: 4096-bit is ~3kB, 8192-bit is ~6kB and a 16k-bit key is ~12kB.
+
+// Certificates have two variables; the public key of the cert, and the signature from the signing cert.
+// An N-bit key produces an N-byte signature, so as a worst case for us, a 16kB RSA key will create a 2kB signature.
+
+// PEM-encoded RSA X.509 certificates:
+// Signed with  1k-bit RSA key: 4096-bit is ~1.4kB, 8192-bit is ~2kB, 16k-bit is ~3.5kB
+// Signed with 16k-bit RSA key: 4096-bit is ~3.3kB, 8192-bit is ~4kB, 16k-bit is ~5.4kB
+
+// See https://fm4dd.com/openssl/certexamples.shtm for examples of large RSA certs / keys
+
+const (
+	// maxCertificatePEMSize is the maximum size, in bytes, of a single PEM-encoded X.509 certificate which SafeDecodeSingleCertificate will accept.
+	// The value is based on how large a "realistic" (but still very large) self-signed 16k-bit RSA certficate might be.
+	// 16k-bit RSA keys are impractical on most on modern hardware due to how slow they can be,
+	// so we can reasonably assume that no real-world PEM-encoded X.509 cert will be this large.
+	// Note that X.509 certificates can contain extra abitrary data (e.g. DNS names, policy names, etc) whose size is hard to predict.
+	// So we guess at how much of that data we'll allow in very large certs and allow about 1kB of such data.
+	maxCertificatePEMSize = 6500
+
+	// maxPrivateKeyPEMSize is the maximum size, in bytes, of PEM-encoded private keys which SafeDecodePrivateKey will accept.
+	// cert-manager supports RSA, ECDSA and Ed25519 keys, of which RSA is by far the largest.
+	// The value is based on how large a "realistic" (but very large) 16k-bit RSA private key might be.
+	// Given that 16k-bit RSA keys are so slow to use as to be impractical on modern hardware,
+	// we can reasonably assume that no real-world PEM-encoded key will be this large.
+	maxPrivateKeyPEMSize = 13000
+
+	// maxChainSize is the maximum number of 16k-bit RSA certificates signed by 16k-bit RSA CAs we'll allow in a given call to SafeDecodeMultipleCertificates.
+	// This is _not_ the maximum number of certificates cert-manager will process in a given chain, which could be much larger.
+	// This is simply the maximum number of worst-case certificates we'll accept in a chain.
+	maxChainSize = 10
+)
+
+var (
+	// ErrNoPEMData is returned when the given data contained no PEM
+	ErrNoPEMData = errors.New("no PEM data was found in given input")
+)
+
+// ErrPEMDataTooLarge is returned when the given data is larger than the maximum allowed
+type ErrPEMDataTooLarge int
+
+// Error returns an error string
+func (e ErrPEMDataTooLarge) Error() string {
+	return fmt.Sprintf("provided PEM data was larger than the maximum %dB", int(e))
+}
+
+func safeDecodeInternal(b []byte, maxSize int) (*stdpem.Block, []byte, error) {
+	if len(b) > maxSize {
+		return nil, b, ErrPEMDataTooLarge(maxSize)
+	}
+
+	block, rest := stdpem.Decode(b)
+	if block == nil {
+		return nil, rest, ErrNoPEMData
+	}
+
+	return block, rest, nil
+}
+
+// SafeDecodePrivateKey calls [encoding/pem.Decode] on the given input as long as it's within a sensible range for
+// how large we expect a private key to be. The baseline is a 16k-bit RSA private key, which is larger than the maximum
+// supported by cert-manager for key generation.
+func SafeDecodePrivateKey(b []byte) (*stdpem.Block, []byte, error) {
+	return safeDecodeInternal(b, maxPrivateKeyPEMSize)
+}
+
+// SafeDecodeCSR calls [encoding/pem.Decode] on the given input as long as it's within a sensible range for
+// how large we expect a single PEM-encoded PKCS#10 CSR to be.
+// We assume that a PKCS#12 CSR is smaller than a single certificate because our assumptions are that
+// a certificate has a large public key and a large signature, which is roughly the case for a CSR.
+// We also assume that we'd only ever decode one CSR which is the case in practice.
+func SafeDecodeCSR(b []byte) (*stdpem.Block, []byte, error) {
+	return safeDecodeInternal(b, maxCertificatePEMSize)
+}
+
+// SafeDecodeSingleCertificate calls [encoding/pem.Decode] on the given input as long as it's within a sensible range for
+// how large we expect a single PEM-encoded X.509 certificate to be.
+// The baseline is a 16k-bit RSA certificate signed by a different 16k-bit RSA CA, which is larger than the maximum
+// supported by cert-manager for key generation.
+func SafeDecodeSingleCertificate(b []byte) (*stdpem.Block, []byte, error) {
+	return safeDecodeInternal(b, maxCertificatePEMSize)
+}
+
+// SafeDecodeMultipleCertificates calls [encoding/pem.Decode] on the given input as long as it's within a sensible range for
+// how large we expect a reasonable-length PEM-encoded X.509 certificate chain to be.
+// The baseline is several 16k-bit RSA certificates, all signed by 16k-bit RSA keys, which is larger than the maximum
+// supported by cert-manager for key generation.
+// The maximum number of chains supported by this function is not reflective of the maximum chain length supported by
+// cert-manager; a larger chain of smaller certificate should be supported.
+func SafeDecodeMultipleCertificates(b []byte) (*stdpem.Block, []byte, error) {
+	return safeDecodeInternal(b, maxCertificatePEMSize*maxChainSize)
+}
diff --git a/internal/pem/decode_test.go b/internal/pem/decode_test.go
new file mode 100644
index 0000000..099dacf
--- /dev/null
+++ b/internal/pem/decode_test.go
@@ -0,0 +1,160 @@
+/*
+Copyright 2024 The cert-manager Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package pem
+
+import (
+	stdpem "encoding/pem"
+	"fmt"
+	"os"
+	"slices"
+	"testing"
+	"time"
+)
+
+// fuzzFile is a fuzz-test-generated file which causes significant slowdown when passed to
+// the standard library pem.Decode function. It's used as a test case to ensure that our
+// safe PEM decoding functions reject it.
+var fuzzFile []byte
+
+// pathologicalFuzzFile is a copy of fuzzFile trimmed to fit inside our max allowable size
+var pathologicalFuzzFile []byte
+
+func init() {
+	fuzzFilename := "./testdata/issue-ghsa-r4pg-vg54-wxx4.bin"
+
+	var err error
+	fuzzFile, err = os.ReadFile(fuzzFilename)
+	if err != nil {
+		panic(fmt.Errorf("failed to read fuzz file %q: %s", fuzzFilename, err))
+	}
+
+	maxChainSize := maxCertificatePEMSize * maxChainSize
+
+	// Assert that SafeDecodeMultipleCertificates has the largest max size so we're definitely
+	// testing the worst case with pathologicalFuzzFile
+	if maxChainSize < maxPrivateKeyPEMSize {
+		panic(fmt.Errorf("invalid test: expected max cert chain size %d to be larger than maxPrivateKeyPEMSize %d", maxChainSize, maxPrivateKeyPEMSize))
+	}
+
+	pathologicalFuzzFile = fuzzFile[:maxChainSize-1]
+}
+
+func TestFuzzData(t *testing.T) {
+	// The fuzz test data should be rejected by all Safe* functions
+
+	// Ensure fuzz test data is larger than the max we allow
+	if len(fuzzFile) < maxCertificatePEMSize*maxChainSize {
+		t.Fatalf("invalid test; fuzz file data is smaller than the maximum allowed input")
+	}
+
+	var block *stdpem.Block
+	var rest []byte
+	var err error
+
+	expPrivateKeyError := ErrPEMDataTooLarge(maxPrivateKeyPEMSize)
+	expCSRError := ErrPEMDataTooLarge(maxCertificatePEMSize)
+	expSingleCertError := ErrPEMDataTooLarge(maxCertificatePEMSize)
+	expMultiCertError := ErrPEMDataTooLarge(maxCertificatePEMSize * maxChainSize)
+
+	block, rest, err = SafeDecodePrivateKey(fuzzFile)
+	if err != expPrivateKeyError {
+		t.Errorf("SafeDecodePrivateKey: wanted %s but got %v", expPrivateKeyError, err)
+	}
+
+	if block != nil {
+		t.Errorf("SafeDecodePrivateKey: expected block to be nil")
+	}
+
+	if !slices.Equal(rest, fuzzFile) {
+		t.Errorf("SafeDecodePrivateKey: expected rest to equal input")
+	}
+
+	block, rest, err = SafeDecodeCSR(fuzzFile)
+	if err != expCSRError {
+		t.Errorf("SafeDecodeCSR: wanted %s but got %v", expCSRError, err)
+	}
+
+	if block != nil {
+		t.Errorf("SafeDecodeCSR: expected block to be nil")
+	}
+
+	if !slices.Equal(rest, fuzzFile) {
+		t.Errorf("SafeDecodeCSR: expected rest to equal input")
+	}
+
+	block, rest, err = SafeDecodeSingleCertificate(fuzzFile)
+	if err != expSingleCertError {
+		t.Errorf("SafeDecodeSingleCertificate: wanted %s but got %v", expSingleCertError, err)
+	}
+
+	if block != nil {
+		t.Errorf("SafeDecodeSingleCertificate: expected block to be nil")
+	}
+
+	if !slices.Equal(rest, fuzzFile) {
+		t.Errorf("SafeDecodeSingleCertificate: expected rest to equal input")
+	}
+
+	block, rest, err = SafeDecodeMultipleCertificates(fuzzFile)
+	if err != expMultiCertError {
+		t.Errorf("SafeDecodeMultipleCertificates: wanted %s but got %v", expMultiCertError, err)
+	}
+
+	if block != nil {
+		t.Errorf("SafeDecodeSingleCertificate: expected block to be nil")
+	}
+
+	if !slices.Equal(rest, fuzzFile) {
+		t.Errorf("SafeDecodeMultipleCertificates: expected rest to equal input")
+	}
+}
+
+func testPathologicalInternal(t testing.TB) {
+	block, rest, err := SafeDecodeMultipleCertificates(pathologicalFuzzFile)
+
+	if err != ErrNoPEMData {
+		t.Errorf("pathological input: expected err %s but got %v", ErrNoPEMData, err)
+	}
+
+	if block != nil {
+		t.Errorf("pathological input: expected block to be nil")
+	}
+
+	if !slices.Equal(rest, pathologicalFuzzFile) {
+		t.Errorf("pathological input: expected rest to equal input")
+	}
+}
+
+func TestPathologicalInput(t *testing.T) {
+	// This test checks the runtime of the worst case scenario, so we can check it's not unacceptably
+	// slow (indicating that our max sizes might be too permissive)
+	beforeCall := time.Now()
+
+	testPathologicalInternal(t)
+
+	afterCall := time.Now()
+
+	callDuration := afterCall.Sub(beforeCall)
+
+	t.Logf("pathological input: took %s to execute", callDuration)
+}
+
+func BenchmarkPathologicalInput(b *testing.B) {
+	for n := 0; n < b.N; n++ {
+		testPathologicalInternal(b)
+	}
+}
diff --git a/internal/pem/testdata/issue-ghsa-r4pg-vg54-wxx4.bin b/internal/pem/testdata/issue-ghsa-r4pg-vg54-wxx4.bin
new file mode 100644
index 0000000000000000000000000000000000000000..f47fb26776347ccc8608d7a912c2b54f9d5aca47
GIT binary patch
literal 876105
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

literal 0
HcmV?d00001

diff --git a/pkg/util/pki/generate_keysize_test.go b/pkg/util/pki/generate_keysize_test.go
new file mode 100644
index 0000000..d615c61
--- /dev/null
+++ b/pkg/util/pki/generate_keysize_test.go
@@ -0,0 +1,27 @@
+/*
+Copyright 2024 The cert-manager Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package pki
+
+import "testing"
+
+func TestMaxRSAKeySizeSanity(t *testing.T) {
+	// This test ensures that if we bump our max RSA key size in the future, someone will come and
+	// re-check our assumptions about max PEM sizes.
+	if MaxRSAKeySize > 8192 {
+		t.Fatalf("MaxRSAKeySize has been increased which may invalidate the assumptions for safe PEM decoding in internal/pem/*.go\nCheck the max sizes and change this test once complete!")
+	}
+}
diff --git a/pkg/util/pki/parse.go b/pkg/util/pki/parse.go
index 8eeb65f..af2c524 100644
--- a/pkg/util/pki/parse.go
+++ b/pkg/util/pki/parse.go
@@ -26,7 +26,7 @@ import (
 )
 
 // DecodePrivateKeyBytes will decode a PEM encoded private key into a crypto.Signer.
-// It supports ECDSA and RSA private keys only. All other types will return err.
+// It supports ECDSA, RSA and EdDSA private keys only. All other types will return err.
 func DecodePrivateKeyBytes(keyBytes []byte) (crypto.Signer, error) {
 	// decode the private key pem
 	block, _ := pem.Decode(keyBytes)
-- 
2.34.1


From 69174efc1b3adee5d46a171fa057f327cfd30454 Mon Sep 17 00:00:00 2001
From: Ashley Davis <ashley.davis@venafi.com>
Date: Tue, 5 Nov 2024 15:35:33 +0000
Subject: security: remove calls to pem.Decode in non-test code

The changes are much smaller scoped in release-1.12 due to bigger diffs with master

Signed-off-by: Ashley Davis <ashley.davis@venafi.com>
---
 internal/controller/certificates/secrets.go | 10 +++++--
 pkg/controller/acmeorders/sync.go           | 20 +++++++++-----
 pkg/util/pki/csr.go                         | 13 ++++-----
 pkg/util/pki/parse.go                       | 29 ++++++++++++---------
 4 files changed, 45 insertions(+), 27 deletions(-)

diff --git a/internal/controller/certificates/secrets.go b/internal/controller/certificates/secrets.go
index cbec678..a1b007f 100644
--- a/internal/controller/certificates/secrets.go
+++ b/internal/controller/certificates/secrets.go
@@ -19,9 +19,9 @@ package certificates
 import (
 	"bytes"
 	"crypto/x509"
-	"encoding/pem"
 	"strings"
 
+	"github.com/cert-manager/cert-manager/internal/pem"
 	apiutil "github.com/cert-manager/cert-manager/pkg/api/util"
 	cmapi "github.com/cert-manager/cert-manager/pkg/apis/certmanager/v1"
 	cmutil "github.com/cert-manager/cert-manager/pkg/util"
@@ -96,7 +96,13 @@ func AnnotationsForCertificateSecret(crt *cmapi.Certificate, certificate *x509.C
 // OutputFormatDER returns the byte slice of the private key in DER format. To
 // be used for Certificate's Additional Output Format DER.
 func OutputFormatDER(privateKey []byte) []byte {
-	block, _ := pem.Decode(privateKey)
+	// NOTE: This call to pem.SafeDecodePrivateKey ignores errors.
+	// This is acceptable here since we're calling this function only on PEM data which we created
+	// by encoding the private key. As such, we can be fairly confident that:
+	// 1) The PEM is valid
+	// 2) The PEM isn't attacker-controlled (and as such unsafe to decode)
+
+	block, _, _ := pem.SafeDecodePrivateKey(privateKey)
 	return block.Bytes
 }
 
diff --git a/pkg/controller/acmeorders/sync.go b/pkg/controller/acmeorders/sync.go
index 9ab7402..dcabc62 100644
--- a/pkg/controller/acmeorders/sync.go
+++ b/pkg/controller/acmeorders/sync.go
@@ -20,7 +20,7 @@ import (
 	"bytes"
 	"context"
 	"crypto/x509"
-	"encoding/pem"
+	stdpem "encoding/pem"
 	"fmt"
 	"time"
 
@@ -36,6 +36,7 @@ import (
 
 	"github.com/cert-manager/cert-manager/internal/controller/feature"
 	internalorders "github.com/cert-manager/cert-manager/internal/controller/orders"
+	"github.com/cert-manager/cert-manager/internal/pem"
 	"github.com/cert-manager/cert-manager/pkg/acme"
 	acmecl "github.com/cert-manager/cert-manager/pkg/acme/client"
 	cmacme "github.com/cert-manager/cert-manager/pkg/apis/acme/v1"
@@ -515,13 +516,18 @@ func (c *controller) finalizeOrder(ctx context.Context, cl acmecl.Interface, o *
 	// only supported DER encoded CSRs and not PEM encoded as they are intended
 	// to be as part of our API.
 	// To work around this, we first attempt to decode the Request into DER bytes
-	// by running pem.Decode. If the PEM block is empty, we assume that the Request
+	// by running pem.SafeDecodeCSR. If the PEM block is empty, we assume that the Request
 	// is DER encoded and continue to call FinalizeOrder.
 	var derBytes []byte
-	block, _ := pem.Decode(o.Spec.Request)
-	if block == nil {
-		log.V(logf.WarnLevel).Info("failed to parse Request as PEM data, attempting to treat Request as DER encoded for compatibility reasons")
-		derBytes = o.Spec.Request
+	block, _, err := pem.SafeDecodeCSR(o.Spec.Request)
+
+	if err != nil {
+		if err == pem.ErrNoPEMData {
+			log.V(logf.WarnLevel).Info("failed to parse Request as PEM data, attempting to treat Request as DER encoded for compatibility reasons")
+			derBytes = o.Spec.Request
+		} else {
+			return err
+		}
 	} else {
 		derBytes = block.Bytes
 	}
@@ -606,7 +612,7 @@ func (c *controller) storeCertificateOnStatus(ctx context.Context, o *cmacme.Ord
 	// encode the retrieved certificates (including the chain)
 	certBuffer := bytes.NewBuffer([]byte{})
 	for _, cert := range certs {
-		err := pem.Encode(certBuffer, &pem.Block{Type: "CERTIFICATE", Bytes: cert})
+		err := stdpem.Encode(certBuffer, &stdpem.Block{Type: "CERTIFICATE", Bytes: cert})
 		if err != nil {
 			log.Error(err, "invalid certificate data returned by ACME server")
 			c.setOrderState(&o.Status, string(cmacme.Errored))
diff --git a/pkg/util/pki/csr.go b/pkg/util/pki/csr.go
index ad8a0de..ad56016 100644
--- a/pkg/util/pki/csr.go
+++ b/pkg/util/pki/csr.go
@@ -22,7 +22,7 @@ import (
 	"crypto/rand"
 	"crypto/x509"
 	"crypto/x509/pkix"
-	"encoding/pem"
+	stdpem "encoding/pem"
 	"errors"
 	"fmt"
 	"math/big"
@@ -32,6 +32,7 @@ import (
 	"time"
 
 	"github.com/cert-manager/cert-manager/internal/controller/feature"
+	"github.com/cert-manager/cert-manager/internal/pem"
 	apiutil "github.com/cert-manager/cert-manager/pkg/api/util"
 	v1 "github.com/cert-manager/cert-manager/pkg/apis/certmanager/v1"
 	utilfeature "github.com/cert-manager/cert-manager/pkg/util/feature"
@@ -380,8 +381,8 @@ func GenerateTemplateFromCSRPEM(csrPEM []byte, duration time.Duration, isCA bool
 }
 
 func GenerateTemplateFromCSRPEMWithUsages(csrPEM []byte, duration time.Duration, isCA bool, keyUsage x509.KeyUsage, extKeyUsage []x509.ExtKeyUsage) (*x509.Certificate, error) {
-	block, _ := pem.Decode(csrPEM)
-	if block == nil {
+	block, _, err := pem.SafeDecodeCSR(csrPEM)
+	if err != nil {
 		return nil, errors.New("failed to decode csr")
 	}
 
@@ -443,7 +444,7 @@ func SignCertificate(template *x509.Certificate, issuerCert *x509.Certificate, p
 	}
 
 	pemBytes := bytes.NewBuffer([]byte{})
-	err = pem.Encode(pemBytes, &pem.Block{Type: "CERTIFICATE", Bytes: derBytes})
+	err = stdpem.Encode(pemBytes, &stdpem.Block{Type: "CERTIFICATE", Bytes: derBytes})
 	if err != nil {
 		return nil, nil, fmt.Errorf("error encoding certificate PEM: %s", err.Error())
 	}
@@ -489,7 +490,7 @@ func EncodeCSR(template *x509.CertificateRequest, key crypto.Signer) ([]byte, er
 // EncodeX509 will encode a single *x509.Certificate into PEM format.
 func EncodeX509(cert *x509.Certificate) ([]byte, error) {
 	caPem := bytes.NewBuffer([]byte{})
-	err := pem.Encode(caPem, &pem.Block{Type: "CERTIFICATE", Bytes: cert.Raw})
+	err := stdpem.Encode(caPem, &stdpem.Block{Type: "CERTIFICATE", Bytes: cert.Raw})
 	if err != nil {
 		return nil, err
 	}
@@ -515,7 +516,7 @@ func EncodeX509Chain(certs []*x509.Certificate) ([]byte, error) {
 			continue
 		}
 
-		err := pem.Encode(caPem, &pem.Block{Type: "CERTIFICATE", Bytes: cert.Raw})
+		err := stdpem.Encode(caPem, &stdpem.Block{Type: "CERTIFICATE", Bytes: cert.Raw})
 		if err != nil {
 			return nil, err
 		}
diff --git a/pkg/util/pki/parse.go b/pkg/util/pki/parse.go
index af2c524..af15594 100644
--- a/pkg/util/pki/parse.go
+++ b/pkg/util/pki/parse.go
@@ -20,8 +20,9 @@ import (
 	"crypto"
 	"crypto/rsa"
 	"crypto/x509"
-	"encoding/pem"
+	stdpem "encoding/pem"
 
+	"github.com/cert-manager/cert-manager/internal/pem"
 	"github.com/cert-manager/cert-manager/pkg/util/errors"
 )
 
@@ -29,8 +30,8 @@ import (
 // It supports ECDSA, RSA and EdDSA private keys only. All other types will return err.
 func DecodePrivateKeyBytes(keyBytes []byte) (crypto.Signer, error) {
 	// decode the private key pem
-	block, _ := pem.Decode(keyBytes)
-	if block == nil {
+	block, _, err := pem.SafeDecodePrivateKey(keyBytes)
+	if err != nil {
 		return nil, errors.NewInvalidData("error decoding private key PEM block")
 	}
 
@@ -72,8 +73,8 @@ func DecodePrivateKeyBytes(keyBytes []byte) (crypto.Signer, error) {
 // DecodePKCS1PrivateKeyBytes will decode a PEM encoded RSA private key.
 func DecodePKCS1PrivateKeyBytes(keyBytes []byte) (*rsa.PrivateKey, error) {
 	// decode the private key pem
-	block, _ := pem.Decode(keyBytes)
-	if block == nil {
+	block, _, err := pem.SafeDecodePrivateKey(keyBytes)
+	if err != nil {
 		return nil, errors.NewInvalidData("error decoding private key PEM block")
 	}
 	// parse the private key
@@ -97,13 +98,17 @@ func DecodeX509CertificateChainBytes(certBytes []byte) ([]*x509.Certificate, err
 func DecodeX509CertificateSetBytes(certBytes []byte) ([]*x509.Certificate, error) {
 	certs := []*x509.Certificate{}
 
-	var block *pem.Block
+	var block *stdpem.Block
+	var err error
 
 	for {
-		// decode the tls certificate pem
-		block, certBytes = pem.Decode(certBytes)
-		if block == nil {
-			break
+		block, certBytes, err = pem.SafeDecodeMultipleCertificates(certBytes)
+		if err != nil {
+			if err == pem.ErrNoPEMData {
+				break
+			}
+
+			return nil, err
 		}
 
 		// parse the tls certificate
@@ -133,8 +138,8 @@ func DecodeX509CertificateBytes(certBytes []byte) (*x509.Certificate, error) {
 
 // DecodeX509CertificateRequestBytes will decode a PEM encoded x509 Certificate Request.
 func DecodeX509CertificateRequestBytes(csrBytes []byte) (*x509.CertificateRequest, error) {
-	block, _ := pem.Decode(csrBytes)
-	if block == nil {
+	block, _, err := pem.SafeDecodeCSR(csrBytes)
+	if err != nil {
 		return nil, errors.NewInvalidData("error decoding certificate request PEM block")
 	}
 
-- 
2.34.1

