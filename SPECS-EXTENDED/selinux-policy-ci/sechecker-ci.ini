#
# This file is not installed on the system. It is used for validating
# the policy during development.
#
# You can test the policy by installing setools and running:
#      sechecker sechecker-ci.ini policy.33
# where policy.33 is at /etc/selinux/targeted/policy/policy.33 on the image.

[INTEGRITY-executables]
check_type = ro_execs
exempt_write_domain = kernel_t # due to overlay use
                      mount_t # due to overlay use
                      container_domain # not addressed in M1
                      container_engine_domain # not addressed in M1
                      rpm_t # required
                      rpm_script_t # required
exempt_exec_domain = kernel_t # due to unconfined (overlay use)
                     mount_t # due to unconfined (overlay use)
                     container_domain # not addressed in M1
                     container_engine_domain # not addressed in M1
exempt_file = cloud_init_state_t # by cloud-init's design
              cron_spool_type # by cron's design
              etc_t # there are scripts mixed in with config files
              kubernetes_plugin_t # not addressed in M1, may be required due to its design
              logrotate_tmp_t # by logrotate's design
              rpm_tmp_t rpm_tmpfs_t rpm_script_tmp_t rpm_script_tmpfs_t # by rpm's design

[INTEGRITY-executables-mounton]
check_type = assert_te
desc = Verify no domains can mount over executables.
target = exec_type
tclass = file
perms = mounton
exempt_source = container_engine_domain # not addressed in M1
                kubernetes_container_engine_domain # not addressed in M1
                spc_t # not addressed in M1

[INTEGRITY-execmem]
check_type = assert_te
desc = Verify only expected domains have executable memory
       (see execmem in https://www.akkadia.org/drepper/selinux-mem.html)
tclass = process
perms = execmem
# policykit_t: probably due to the javascript-based config engine
exempt_source = kmod_t policykit_t policykit_auth_t policykit_grant_t policykit_resolve_t
                udev_t
disable = not addressed for M1

[INTEGRITY-execstack]
check_type = assert_te
desc = Verify only expected domains have executable stacks
       (see execstack in https://www.akkadia.org/drepper/selinux-mem.html)
tclass = process
perms = execstack
# fsadm_t: From upstream. Unclear why. fs check tools
exempt_source = fsadm_t
disable = not addressed for M1

[INTEGRITY-execheap]
check_type = assert_te
desc = Verify no domains have executable heap
       (see execheap in https://www.akkadia.org/drepper/selinux-mem.html)
tclass = process
perms = execheap
disable = not addressed for M1

[INTEGRITY-grub.cfg]
check_type = assert_te
desc = Verify the grub config/booloader files are only modifiable by expected programs.
target = boot_t
tclass = file
perms = create write append
disable = not addressed for M1

[INTEGRITY-kernel_image]
check_type = assert_te
desc = Verify the kernel image and booloader files are only modifiable by expected programs.
target = boot_t
tclass = file
perms = create write append
#exempt_source = kdumpctl_t
disable = not addressed for M1

[INTEGRITY-kernel_modules]
check_type = assert_te
desc = Verify kernel modules are read-only.
target = modules_object_t
tclass = file
perms = create write append
# kmod_t: this is the kernel module loader
exempt_source = kmod_t
disable = not addressed for M1

[INTEGRITY-raw-block-read]
check_type = assert_te
desc = Raw read access to block devices can only be done by expected domains.
       The block devices created by veritysetup for squashfs images also have this label.
target = fixed_disk_device_t
tclass = blk_file
perms = read
# fsadm_t: fsck
# lvm_t: veritysetup
exempt_source = fsadm_t init_t initrc_t kernel_t kdumpctl_t lvm_t mount_t
                systemd_generator_t udev_t
disable = not addressed for M1

[INTEGRITY-raw-block-write]
check_type = assert_te
desc = Raw write access to block devices can only be done by expected domains.
       The block devices created by veritysetup for squashfs images also have this label.
target = fixed_disk_device_t
tclass = blk_file
perms = write append
# fsadm_t: fsck
# lvm_t: veritysetup
exempt_source = clvmd_t fsadm_t init_t initrc_t kernel_t kdumpctl_t lvm_t mount_t udev_t
disable = not addressed for M1

[INTEGRITY-passwords]
check_type = assert_te
desc = Verify /etc/shadow is only modifiable by expected programs.
target = shadow_t
tclass = file
perms = create write append
exempt_source = updpwd_t systemd_sysusers_t
disable = not addressed for M1

[INTEGRITY-SELinux_policy_file]
check_type = assert_te
desc = Verify SELinux policy binary file is read-only.
target = policy_config_t
tclass = file
perms = create write append
exempt_source = semanage_t
disable = not addressed for M1

[INTEGRITY-SELinux-policy-file-mounton]
check_type = assert_te
desc = Verify no domains can mount over the policy file.
target = policy_config_t
tclass = file
perms = mounton
disable = not addressed for M1

[INTEGRITY-SELinux_config]
check_type = assert_te
desc = Verify /etc/selinux/config is read-only.
target = selinux_config_t
tclass = file
perms = create write append
exempt_source = semanage_t
disable = not addressed for M1

[INTEGRITY-SELinux-config-mounton]
check_type = assert_te
desc = Verify only expected domains can mount over the policy dir.
target = selinux_config_t
tclass = file dir
perms = mounton
# systemd can mount over any mount point, e.g. using the bind mount option.
#exempt_source = init_t mount_t
disable = not addressed for M1

[INTEGRITY-General_config]
check_type = assert_te
desc = Verify general config files in /etc are only modifiable by expected domains.
target = etc_t
tclass = file
perms = create write append
# init_t: create mountpoints
#exempt_source = init_t systemd_sysusers_t updpwd_t
disable = not addressed for M1

[INTEGRITY-unlabeled-files]
check_type = assert_te
desc = Verify no domains can access unlabeled files as they have undefined security characteristics.
target = unlabeled_t
# dir skipped because some access is needed for a few domains to relabel
tclass = file lnk_file sock_file fifo_file blk_file chr_file
perms = read write append
#exempt_source =
disable = not addressed for M1

[INTEGRITY-create-unlabeled-files]
check_type = assert_te
desc = Verify no domains can create unlabeled files as they have undefined security characteristics.
target = unlabeled_t
tclass = dir file lnk_file sock_file fifo_file blk_file chr_file
perms = create relabelto
#exempt_source =
disable = not addressed for M1

[INTEGRITY-default-files]
check_type = assert_te
desc = Verify no domains can access default files as they have undefined security characteristics.
target = default_t
# dir skipped because some access is needed for a few domains to relabel
tclass = file lnk_file sock_file fifo_file blk_file chr_file
perms = read write append
# init_t: create mountpoints
exempt_source = init_t
disable = not addressed for M1

[INTEGRITY-create-default-files]
check_type = assert_te
desc = Verify no domains can create default files as they have undefined security characteristics.
target = default_t
tclass = dir file lnk_file sock_file fifo_file blk_file chr_file
perms = create
# init_t: create mountpoints
exempt_source = init_t
disable = not addressed for M1

[PRIVILEGE-load_policy]
check_type = assert_te
desc = Verify only the load_policy program can load a SELinux policy update.
tclass = security
perms = load_policy
exempt_source = init_t load_policy_t
disable = not addressed for M1

[PRIVILEGE-exec-load_policy]
check_type = assert_te
desc = Verify only expected domains can run the load_policy program.
target = load_policy_t
tclass = process
perms = transition
disable = not addressed for M1

[PRIVILEGE-setbool]
check_type = assert_te
desc = Verify SELinux Booleans can be changed only by expected domains.
tclass = security
perms = setbool
exempt_source =
disable = not addressed for M1

[PRIVILEGE-setenforce]
check_type = assert_te
desc = Verify only expected domains can change SELinux to permissive mode.
tclass = security
perms = setenforce
exempt_source =
disable = not addressed for M1

[PRIVILEGE-CAP_SYS_MODULE]
check_type = assert_te
desc = Verify only expected domains have CAP_SYS_MODULE (kernel module capability)
tclass = capability
perms = sys_module
exempt_source = kernel_t kmod_t init_t systemd_modules_load_t udev_t
disable = not addressed for M1

[PRIVILEGE-module_load]
check_type = assert_te
desc = Verify only expected domains can directly load kernel modules
tclass = system
perms = module_load
exempt_source = kernel_t kmod_t init_t systemd_modules_load_t udev_t
disable = not addressed for M1

[PRIVILEGE-module_request]
check_type = assert_te
desc = Verify only expected domains can request kernel module loading (indirect module load by kernel)
tclass = system
perms = module_request
# For example, if you run mount on a partition it can trigger the kernel to
# load the filesystem kernel module.  This is less concerning than the above module_load
# check because these domains can't influence the path to the module being loaded
# or the contents of the module.
exempt_source = fsadm_t ifconfig_t init_t iptables_t kdump_t kernel_t kmod_t lvm_t mount_t
                systemd_modules_load_t systemd_networkd_t udev_t
disable = not addressed for M1

[PRIVILEGE-CAP_SYS_ADMIN]
check_type = assert_te
desc = Verify only expected domains have CAP_SYS_ADMIN
tclass = capability
perms = sys_admin
# CAP_SYS_ADMIN is a kitchen sink of privileges, which means several domains need it.
exempt_source = consoletype_t dmesg_t fsadm_t getty_t hostname_t ifconfig_t init_t initrc_t
                kdump_t kernel_t lvm_t mananetdevfwd_t mount_t rngd_t sulogin_t syslogd_t
                systemd_hostnamed_t systemd_logind_t systemd_tmpfiles_t
                systemd_user_runtime_dir_t udev_t
disable = not addressed for M1

[PRIVILEGE-CAP_SYS_RAWIO]
check_type = assert_te
desc = Verify only expected domains can use CAP_SYS_RAWIO
tclass = capability
perms = sys_rawio
exempt_source = fsadm_t kdump_t kernel_t hwclock_t init_t
                initrc_t lvm_t mount_t udev_t
disable = not addressed for M1

[PRIVILEGE-CAP_MAC_ADMIN]
check_type = assert_te
desc = Verify only expected domains can use CAP_MAC_ADMIN.
tclass = capability2
perms = mac_admin
disable = not addressed for M1

[PRIVILEGE-CAP_MAC_OVERRIDE]
check_type = assert_te
desc = Verify no domains can use CAP_MAC_OVERRIDE.
tclass = capability2
perms = mac_override
disable = not addressed for M1

[PRIVILEGE-setcurrent]
check_type = assert_te
desc = Verify only the expected domains can change their process label.
tclass = process
perms = setcurrent
# When systemd loads the policy it has the kernel_t label and must
# change its label to init_t
exempt_source = kernel_t
disable = not addressed for M1

[NONTRANQUILITY-systemd]
check_type = assert_te
desc = Verify dynamic transition allowed by PRIVILEGE-setcurrent test can only
       go from kernel_t to init_t (systemd)
source = kernel_t
tclass = process
perms = dyntransition
# kernel_t -> kernel_t and kernel_t -> init_t
exempt_target = init_t kernel_t
disable = not addressed for M1

[UNCONFINED-unconfined_domain_type]
check_type = empty_typeattr
desc = Verify unconfined_domain_type is empty. This provides unconfined process
       access. (e.g. send signals, set resource limits)
attr = unconfined_domain_type
missing_ok = true

[UNCONFINED-kern_unconfined]
check_type = empty_typeattr
desc = Verify kern_unconfined is empty. This provides unconfined access to kernel resources.
attr = kern_unconfined
missing_ok = true
disable = Required for overlays

[UNCONFINED-files_unconfined_type]
check_type = empty_typeattr
desc = Verify files_unconfined_type is empty. This provides unconfined access to files.
attr = files_unconfined_type
missing_ok = true
disable = Required for overlays

[UNCONFINED-filesystem_unconfined_type]
check_type = empty_typeattr
desc = Verify filesystem_unconfined_type is empty. This provides unconfined access
       to filesystem superblocks and namespacing
attr = filesystem_unconfined_type
missing_ok = true

[UNCONFINED-corenet_unconfined_type]
check_type = empty_typeattr
desc = Verify corenet_unconfined_type is empty. This provides unconfined network access
attr = corenet_unconfined_type
missing_ok = true

[UNCONFINED-selinux_unconfined_type]
check_type = empty_typeattr
desc = Verify selinux_unconfined_type is empty. This provides unconfined access
       to SELinux resources
attr = selinux_unconfined_type
missing_ok = true

[UNCONFINED-devices_unconfined_type]
check_type = empty_typeattr
desc = Verify devices_unconfined_type is empty. This provides unconfined access
       to devices (except storage devices)
attr = devices_unconfined_type
missing_ok = true

[UNCONFINED-storage_unconfined_type]
check_type = empty_typeattr
desc = Verify storage_unconfined_type is empty. This provides unconfined access
       to storage devices
attr = storage_unconfined_type
missing_ok = true

[UNCONFINED-sepgsql_unconfined_type]
check_type = empty_typeattr
desc = Verify sepgsql_unconfined_type is empty. This provides unconfined access
       to SEPostgresql DBs
attr = sepgsql_unconfined_type
# don't fail if this attr is missing
missing_ok = true

[UNCONFINED-xserver_unconfined_type]
check_type = empty_typeattr
desc = Verify xserver_unconfined_type is empty. This provides unconfined access
       to X server resources
attr = xserver_unconfined_type
# don't fail if this attr is missing
missing_ok = true
